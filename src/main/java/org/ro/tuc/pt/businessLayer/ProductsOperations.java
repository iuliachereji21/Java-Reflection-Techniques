package org.ro.tuc.pt.businessLayer;

import org.ro.tuc.pt.dataAccessLayer.ConnectionFactory;
import org.ro.tuc.pt.dataAccessLayer.DataAccessClass;
import org.ro.tuc.pt.model.Product;
import org.ro.tuc.pt.presentation.MainFrame;
import org.ro.tuc.pt.presentation.OrderViewPanel;
import org.ro.tuc.pt.presentation.ProductsViewPanel;
import java.util.ArrayList;

/**
 * This class will be used for managing product operations.
 * It reads from and writes to the product table in the database.
 * @author Chereji Iulia
 */
public class ProductsOperations {
    private ArrayList<Product> products;
    private DataAccessClass<Product> productDAO;
    private MainFrame mainFrame;
    private int newID;

    /**
     * Creates a new instance of ProductsOperations.
     * @param connectionFactory is the object holding the connection to the database.
     * @param mainFrame is the main window of the application, which will have to be updated in this class when client changes are made.
     */
    public ProductsOperations(ConnectionFactory connectionFactory, MainFrame mainFrame)
    {
        this.mainFrame=mainFrame;
        productDAO= new DataAccessClass<Product>(connectionFactory, new Product());
        products= productDAO.findAll();
        newID= products.get(products.size()-1).getId()+1;
    }

    /**
     * @return the list of the application's currently existing products.
     */
    public ArrayList<Product> getProducts() {
        return products;
    }

    /**
     * @param id the id of the product we want to find.
     * @return reference to an object of type Product if the id is found, or null if the id is not found.
     */
    public Product getProductByID(int id)
    {
        for(int i=0;i<products.size();i++)
            if(products.get(i).getId()==id)
                return products.get(i);
        return null; //not found
    }

    /**
     * it updates the data specific to a product in the database and in the GUI.
     * @param product the Product that will be updated.
     */
    public void updateProduct(Product product)
    {
        productDAO.update(product);
        ((ProductsViewPanel)mainFrame.panels[1]).updateTable(products);
    }

    /**
     * Validates the input provided by the user when trying to edit/add a product.
     * If the input is correct, it edits/inserts the new product and makes the neccessary updates in the GUI and in the database.
     * @param id provided a valid integer (not user input but generated by the application).
     * @param name checked to be not empty.
     * @param price checked to be not empty and be a valid float value.
     * @param stock checked to be not empty and be a valid integer value.
     * @return -1 if the input is correct and the updates were made, 0 if the name is incorrect, 1 if the price is incorrect, 2 if the stock is incorrect.
     */
    public int validateProduct(String id, String name, String price, String stock)
    {
        if(name==null || name.isEmpty()) return 0;

        if(price != null && !price.isEmpty()) {
            if(price.length()>10) return 1;
            boolean pointfound=false;
            for(int i=0;i<price.length();i++)
            {
                if(price.charAt(i)=='.')
                    if(!pointfound)
                        pointfound=true;
                    else return 1; //more than 1 point
                else
                if(!Character.isDigit(price.charAt(i))) return 1;
            }
        }else return 1;

        if(stock != null && !stock.isEmpty()) {
            try
            {
                int st=Integer.parseInt(stock);
                if (st<0) return 2;
            }
            catch(NumberFormatException e){ return 2; }
        } else return 2;


        Product product = new Product(Integer.valueOf(id), name, Float.valueOf(price), Integer.parseInt(stock));
        updateProductsList(product);

        return -1;
    }

    private void updateProductsList(Product product)
    {
        int i=0;
        while(i<products.size() && products.get(i).getId()!=product.getId())
            i++;

        if(i==products.size()) //new client
        {
            products.add(product);
            newID++;
            productDAO.insert(product);
        }
        else
        {
            products.set(i,product);
            productDAO.update(product);
        }
        ((ProductsViewPanel)mainFrame.panels[1]).updateTable(products);
        ((OrderViewPanel)mainFrame.panels[2]).updateProductsBox(products);
    }

    /**
     * Deletes the product from the application and makes the updates in the GUI and database.
     * @param id the id of the product that will be deleted, provided it is a valid id.
     */
    public void deleteProduct(int id)
    {
        int i=0;
        while(i<products.size() && products.get(i).getId()!=id)
            i++;
        products.remove(i);
        productDAO.deleteByID(id);
        ((ProductsViewPanel)mainFrame.panels[1]).updateTable(products);
        ((OrderViewPanel)mainFrame.panels[2]).updateProductsBox(products);
    }

    /**
     * @return the id that will be assigned to the next product introduced into the database.
     */
    public int getNewID()
    {
        return newID;
    }

}
